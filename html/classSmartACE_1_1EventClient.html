<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AceSmartSoft API Documentation: SmartACE::EventClient&lt; P, E &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AceSmartSoft API Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSmartACE.html">SmartACE</a></li><li class="navelem"><a class="el" href="classSmartACE_1_1EventClient.html">EventClient</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSmartACE_1_1EventClient-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SmartACE::EventClient&lt; P, E &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Handles the event service on client side.  
 <a href="classSmartACE_1_1EventClient.html#details">More...</a></p>

<p><code>#include &lt;smartEvent.hh&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SmartACE::EventClient&lt; P, E &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSmartACE_1_1EventClient.png" usemap="#SmartACE::EventClient_3C_20P_2C_20E_20_3E_map" alt=""/>
  <map id="SmartACE::EventClient_3C_20P_2C_20E_20_3E_map" name="SmartACE::EventClient_3C_20P_2C_20E_20_3E_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a740e3e323d04134dbdd0cbf081dca9e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1EventClient.html#a740e3e323d04134dbdd0cbf081dca9e6">EventClient</a> (<a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *component, const std::string &amp;port, <a class="el" href="classSmartACE_1_1WiringSlave.html">WiringSlave</a> *slave)</td></tr>
<tr class="memdesc:a740e3e323d04134dbdd0cbf081dca9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor (exposed as port wireable from outside by other components and without handler).  <a href="#a740e3e323d04134dbdd0cbf081dca9e6">More...</a><br /></td></tr>
<tr class="separator:a740e3e323d04134dbdd0cbf081dca9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d7e09d238014008cb2b0e5bffe95d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1EventClient.html#ab3d7e09d238014008cb2b0e5bffe95d6">EventClient</a> (<a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *component)</td></tr>
<tr class="memdesc:ab3d7e09d238014008cb2b0e5bffe95d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor (not wired with service provider, not exposed as port and without handler).  <a href="#ab3d7e09d238014008cb2b0e5bffe95d6">More...</a><br /></td></tr>
<tr class="separator:ab3d7e09d238014008cb2b0e5bffe95d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c97f48e24ffcc232c89fe80972f74d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1EventClient.html#a47c97f48e24ffcc232c89fe80972f74d">EventClient</a> (<a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *component, const std::string &amp;server, const std::string &amp;service)</td></tr>
<tr class="memdesc:a47c97f48e24ffcc232c89fe80972f74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor (wired with specified service provider and without handler)  <a href="#a47c97f48e24ffcc232c89fe80972f74d">More...</a><br /></td></tr>
<tr class="separator:a47c97f48e24ffcc232c89fe80972f74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a3836ada75d63bd5e81a45addbbcf5"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1EventClient.html#a59a3836ada75d63bd5e81a45addbbcf5">~EventClient</a> ()</td></tr>
<tr class="memdesc:a59a3836ada75d63bd5e81a45addbbcf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a59a3836ada75d63bd5e81a45addbbcf5">More...</a><br /></td></tr>
<tr class="separator:a59a3836ada75d63bd5e81a45addbbcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b50aedac98212b8a6372b605ad6096"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1EventClient.html#a14b50aedac98212b8a6372b605ad6096">add</a> (<a class="el" href="classSmartACE_1_1WiringSlave.html">WiringSlave</a> *slave, const std::string &amp;port)</td></tr>
<tr class="memdesc:a14b50aedac98212b8a6372b605ad6096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add this instance to the set of ports wireable via the wiring pattern from outside the component.  <a href="#a14b50aedac98212b8a6372b605ad6096">More...</a><br /></td></tr>
<tr class="separator:a14b50aedac98212b8a6372b605ad6096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4056043ecafd37901fc19784c9d025"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1EventClient.html#adf4056043ecafd37901fc19784c9d025">remove</a> ()</td></tr>
<tr class="memdesc:adf4056043ecafd37901fc19784c9d025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove this service requestor from the set of ports wireable via the wiring pattern from outside the component.  <a href="#adf4056043ecafd37901fc19784c9d025">More...</a><br /></td></tr>
<tr class="separator:adf4056043ecafd37901fc19784c9d025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49300446de97c121cc6c060972dd29f7"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1EventClient.html#a49300446de97c121cc6c060972dd29f7">connect</a> (const std::string &amp;server, const std::string &amp;service)</td></tr>
<tr class="memdesc:a49300446de97c121cc6c060972dd29f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect this service requestor to the denoted service provider.  <a href="#a49300446de97c121cc6c060972dd29f7">More...</a><br /></td></tr>
<tr class="separator:a49300446de97c121cc6c060972dd29f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714b56aeb5c0dc7b76383fb0a3f8850f"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1EventClient.html#a714b56aeb5c0dc7b76383fb0a3f8850f">disconnect</a> ()</td></tr>
<tr class="memdesc:a714b56aeb5c0dc7b76383fb0a3f8850f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect the service requestor from the service provider.  <a href="#a714b56aeb5c0dc7b76383fb0a3f8850f">More...</a><br /></td></tr>
<tr class="separator:a714b56aeb5c0dc7b76383fb0a3f8850f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6db991bffaeca53af71200f09ad5ac"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1EventClient.html#a1f6db991bffaeca53af71200f09ad5ac">blocking</a> (const bool b)</td></tr>
<tr class="memdesc:a1f6db991bffaeca53af71200f09ad5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow or abort and reject blocking calls.  <a href="#a1f6db991bffaeca53af71200f09ad5ac">More...</a><br /></td></tr>
<tr class="separator:a1f6db991bffaeca53af71200f09ad5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa51b95c8eb28aceb5e512608b9bf43"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1EventClient.html#a8fa51b95c8eb28aceb5e512608b9bf43">activate</a> (const Smart::EventMode &amp;mode, const P &amp;parameter, Smart::EventIdPtr &amp;id)</td></tr>
<tr class="memdesc:a8fa51b95c8eb28aceb5e512608b9bf43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate an event with the provided parameters in either "single" or "continuous" mode.  <a href="#a8fa51b95c8eb28aceb5e512608b9bf43">More...</a><br /></td></tr>
<tr class="separator:a8fa51b95c8eb28aceb5e512608b9bf43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a2ade0d5d62129f5846a9b61f72c47"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1EventClient.html#aa3a2ade0d5d62129f5846a9b61f72c47">deactivate</a> (const Smart::EventIdPtr id)</td></tr>
<tr class="memdesc:aa3a2ade0d5d62129f5846a9b61f72c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate the event with the specified identifier.  <a href="#aa3a2ade0d5d62129f5846a9b61f72c47">More...</a><br /></td></tr>
<tr class="separator:aa3a2ade0d5d62129f5846a9b61f72c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63dfe22ff6a226e45224df5813d10d7e"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1EventClient.html#a63dfe22ff6a226e45224df5813d10d7e">tryEvent</a> (const Smart::EventIdPtr id)</td></tr>
<tr class="memdesc:a63dfe22ff6a226e45224df5813d10d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether event has already fired and return immediately with status information.  <a href="#a63dfe22ff6a226e45224df5813d10d7e">More...</a><br /></td></tr>
<tr class="separator:a63dfe22ff6a226e45224df5813d10d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61622ed543663bd4e839dd77a9851cb3"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1EventClient.html#a61622ed543663bd4e839dd77a9851cb3">getEvent</a> (const Smart::EventIdPtr id, E &amp;event, const Smart::Duration &amp;timeout=Smart::Duration::max())</td></tr>
<tr class="memdesc:a61622ed543663bd4e839dd77a9851cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking call which waits for the event to fire and then consumes the event.  <a href="#a61622ed543663bd4e839dd77a9851cb3">More...</a><br /></td></tr>
<tr class="separator:a61622ed543663bd4e839dd77a9851cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05da852031c68725906c612b267e69c2"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1EventClient.html#a05da852031c68725906c612b267e69c2">getNextEvent</a> (const Smart::EventIdPtr id, E &amp;event, const Smart::Duration &amp;timeout=Smart::Duration::max())</td></tr>
<tr class="memdesc:a05da852031c68725906c612b267e69c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking call which waits for the next event.  <a href="#a05da852031c68725906c612b267e69c2">More...</a><br /></td></tr>
<tr class="separator:a05da852031c68725906c612b267e69c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class P, class E&gt;<br />
class SmartACE::EventClient&lt; P, E &gt;</h3>

<p>Handles the event service on client side. </p>
<p>Template parameters:</p><ul>
<li><b>P</b>: Activation parameter class (Communication Object) contains individual parameters of the event activation.</li>
<li><b>E</b>: Event answer class (Communication Object) is returned when an event fires and can contain further details why and under which circumstances an event fired.</li>
</ul>
<p>Demonstrated in <a href="/drupal/?q=node/51#fifth-example">fifth example</a> </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a740e3e323d04134dbdd0cbf081dca9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740e3e323d04134dbdd0cbf081dca9e6">&#9670;&nbsp;</a></span>EventClient() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartACE_1_1EventClient.html">SmartACE::EventClient</a>&lt; P, E &gt;::<a class="el" href="classSmartACE_1_1EventClient.html">EventClient</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSmartACE_1_1WiringSlave.html">WiringSlave</a> *&#160;</td>
          <td class="paramname"><em>slave</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor (exposed as port wireable from outside by other components and without handler). </p>
<p>Constructs an <a class="el" href="classSmartACE_1_1EventClient.html" title="Handles the event service on client side. ">EventClient</a> for method oriented event processing. Use <a class="el" href="classSmartACE_1_1EventClient.html#a63dfe22ff6a226e45224df5813d10d7e" title="Check whether event has already fired and return immediately with status information. ">tryEvent()</a>/getEvent()/getNextEvent() to process incoming events.</p>
<p><a class="el" href="classSmartACE_1_1EventClient.html#a14b50aedac98212b8a6372b605ad6096" title="Add this instance to the set of ports wireable via the wiring pattern from outside the component...">add()</a>/remove() and <a class="el" href="classSmartACE_1_1EventClient.html#a49300446de97c121cc6c060972dd29f7" title="Connect this service requestor to the denoted service provider. ">connect()</a>/disconnect() can always be used to change the status of the instance. Instance is not connected to a service provider.</p>
<p>Throws exception if port name is already in use.</p><ul>
<li>SMART_PORTALREADYUSED : port name already in use, instance not created</li>
<li>SMART_ERROR : something went wrong, instance not created</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>management class of the component </td></tr>
    <tr><td class="paramname">port</td><td>name of the wireable port </td></tr>
    <tr><td class="paramname">slave</td><td>wiring slave of this component </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3d7e09d238014008cb2b0e5bffe95d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d7e09d238014008cb2b0e5bffe95d6">&#9670;&nbsp;</a></span>EventClient() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartACE_1_1EventClient.html">SmartACE::EventClient</a>&lt; P, E &gt;::<a class="el" href="classSmartACE_1_1EventClient.html">EventClient</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor (not wired with service provider, not exposed as port and without handler). </p>
<p>Constructs an <a class="el" href="classSmartACE_1_1EventClient.html" title="Handles the event service on client side. ">EventClient</a> for method oriented event processing. Use <a class="el" href="classSmartACE_1_1EventClient.html#a63dfe22ff6a226e45224df5813d10d7e" title="Check whether event has already fired and return immediately with status information. ">tryEvent()</a>/getEvent()/getNextEvent() to process incoming events.</p>
<p><a class="el" href="classSmartACE_1_1EventClient.html#a14b50aedac98212b8a6372b605ad6096" title="Add this instance to the set of ports wireable via the wiring pattern from outside the component...">add()</a>/remove() and <a class="el" href="classSmartACE_1_1EventClient.html#a49300446de97c121cc6c060972dd29f7" title="Connect this service requestor to the denoted service provider. ">connect()</a>/disconnect() can always be used to change the status of the instance. Instance is not connected to a service provider and is not exposed as port wireable from outside the component.</p>
<p>(Currently exception not thrown)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>management class of the component </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47c97f48e24ffcc232c89fe80972f74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c97f48e24ffcc232c89fe80972f74d">&#9670;&nbsp;</a></span>EventClient() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartACE_1_1EventClient.html">SmartACE::EventClient</a>&lt; P, E &gt;::<a class="el" href="classSmartACE_1_1EventClient.html">EventClient</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor (wired with specified service provider and without handler) </p>
<p>Constructs an <a class="el" href="classSmartACE_1_1EventClient.html" title="Handles the event service on client side. ">EventClient</a> for method oriented event processing. Use <a class="el" href="classSmartACE_1_1EventClient.html#a63dfe22ff6a226e45224df5813d10d7e" title="Check whether event has already fired and return immediately with status information. ">tryEvent()</a>/getEvent()/getNextEvent() to process incoming events. Connects to the denoted service and blocks until the connection has been established. Blocks infinitely if denoted service becomes not available since constructor performs retries. Blocking is useful to simplify startup of components which have mutual dependencies.</p>
<p><a class="el" href="classSmartACE_1_1EventClient.html#a14b50aedac98212b8a6372b605ad6096" title="Add this instance to the set of ports wireable via the wiring pattern from outside the component...">add()</a>/remove() and <a class="el" href="classSmartACE_1_1EventClient.html#a49300446de97c121cc6c060972dd29f7" title="Connect this service requestor to the denoted service provider. ">connect()</a>/disconnect() can always be used to change the status of the instance.</p>
<p>Throws exception if denoted service is incompatible (wrong communication pattern or wrong communication objects).</p><ul>
<li>SMART_INCOMPATIBLESERVICE : the denoted service is incompatible (wrong communication pattern or wrong communication objects) and can therefore not be connected. Instance is not created.</li>
<li>SMART_ERROR : something went wrong, instance not created</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>management class of the component </td></tr>
    <tr><td class="paramname">server</td><td>name of the server </td></tr>
    <tr><td class="paramname">service</td><td>name of the service </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59a3836ada75d63bd5e81a45addbbcf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a3836ada75d63bd5e81a45addbbcf5">&#9670;&nbsp;</a></span>~EventClient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSmartACE_1_1EventClient.html">SmartACE::EventClient</a>&lt; P, E &gt;::~<a class="el" href="classSmartACE_1_1EventClient.html">EventClient</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>The destructor calls <a class="el" href="classSmartACE_1_1EventClient.html#adf4056043ecafd37901fc19784c9d025" title="Remove this service requestor from the set of ports wireable via the wiring pattern from outside the ...">remove()</a> and <a class="el" href="classSmartACE_1_1EventClient.html#a714b56aeb5c0dc7b76383fb0a3f8850f" title="Disconnect the service requestor from the service provider. ">disconnect()</a> and therefore properly deactivates every still active event and removes the instance from the set of wireable ports. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8fa51b95c8eb28aceb5e512608b9bf43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa51b95c8eb28aceb5e512608b9bf43">&#9670;&nbsp;</a></span>activate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1EventClient.html">SmartACE::EventClient</a>&lt; P, E &gt;::activate </td>
          <td>(</td>
          <td class="paramtype">const Smart::EventMode &amp;&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Smart::EventIdPtr &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate an event with the provided parameters in either "single" or "continuous" mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>"single" or "continuous" mode </td></tr>
    <tr><td class="paramname">parameter</td><td>activation parameter class (Communication Object) </td></tr>
    <tr><td class="paramname">id</td><td>is set to the unique id of the event activation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is ok, event is activated and <em>id</em> contains a valid activation identifier.</li>
<li>SMART_DISCONNECTED : activation not possible since not connected to a server. No valid activation identifier <em>id</em> returned.</li>
<li>SMART_ERROR_COMMUNICATION : communication problems, event not activated, <em>id</em> is not a valid activation identifier.</li>
<li>SMART_ERROR : something went wrong, event not activated, <em>id</em> is not a valid activation identifier. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a14b50aedac98212b8a6372b605ad6096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b50aedac98212b8a6372b605ad6096">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1EventClient.html">SmartACE::EventClient</a>&lt; P, E &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSmartACE_1_1WiringSlave.html">WiringSlave</a> *&#160;</td>
          <td class="paramname"><em>slave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add this instance to the set of ports wireable via the wiring pattern from outside the component. </p>
<p>Already established connections keep valid. If this service requestor is already exposed as port, it is first removed and then added with the new port name. <a class="el" href="classSmartACE_1_1EventClient.html#a14b50aedac98212b8a6372b605ad6096" title="Add this instance to the set of ports wireable via the wiring pattern from outside the component...">add()</a>/remove() and <a class="el" href="classSmartACE_1_1EventClient.html#a49300446de97c121cc6c060972dd29f7" title="Connect this service requestor to the denoted service provider. ">connect()</a>/disconnect() can always be used to change the status of this instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slave</td><td>wiring slave of this component </td></tr>
    <tr><td class="paramname">port</td><td>name of port used for wiring</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is OK and this instance added to the set of ports wireable from outside the component</li>
<li>SMART_PORTALREADYUSED : port name already in use and this instance now not available as port</li>
<li>SMART_ERROR : something went wrong </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1f6db991bffaeca53af71200f09ad5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6db991bffaeca53af71200f09ad5ac">&#9670;&nbsp;</a></span>blocking()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1EventClient.html">SmartACE::EventClient</a>&lt; P, E &gt;::blocking </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow or abort and reject blocking calls. </p>
<p>If blocking is set to false all blocking calls return with SMART_CANCELLED. This can be used to abort blocking calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>(blocking) true/false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : new mode set</li>
<li>SMART_ERROR : something went wrong </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a49300446de97c121cc6c060972dd29f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49300446de97c121cc6c060972dd29f7">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1EventClient.html">SmartACE::EventClient</a>&lt; P, E &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect this service requestor to the denoted service provider. </p>
<p>An already established connection is first disconnected. See <a class="el" href="classSmartACE_1_1EventClient.html#a714b56aeb5c0dc7b76383fb0a3f8850f" title="Disconnect the service requestor from the service provider. ">disconnect()</a> for implications on active events in that case.</p>
<p>It is no problem to change the connection to a service provider at any point of time irrespective of any calls to <a class="el" href="classSmartACE_1_1EventClient.html#a63dfe22ff6a226e45224df5813d10d7e" title="Check whether event has already fired and return immediately with status information. ">tryEvent()</a>/getEvent() or <a class="el" href="classSmartACE_1_1EventClient.html#a05da852031c68725906c612b267e69c2" title="Blocking call which waits for the next event. ">getNextEvent()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">server</td><td>name of the server </td></tr>
    <tr><td class="paramname">service</td><td>name of the service</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is OK and connected to the specified service.</li>
<li>SMART_SERVICEUNAVAILABLE : the specified service is currently not available and the requested connection can not be established. Service requestor is now not connected to any service provider.</li>
<li>SMART_INCOMPATIBLESERVICE : the specified service provider is not compatible (wrong communication pattern or wrong communication objects) to this service requestor and can therefore not be connected. Service requestor is now not connected to any service provider.</li>
<li>SMART_ERROR_COMMUNICATION : communication problems, service requestor is now not connected to any service provider.</li>
<li>SMART_ERROR : something went wrong, service requestor is now not connected to any service provider. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa3a2ade0d5d62129f5846a9b61f72c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a2ade0d5d62129f5846a9b61f72c47">&#9670;&nbsp;</a></span>deactivate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1EventClient.html">SmartACE::EventClient</a>&lt; P, E &gt;::deactivate </td>
          <td>(</td>
          <td class="paramtype">const Smart::EventIdPtr&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deactivate the event with the specified identifier. </p>
<p>An event must always be deactivated, even if it has already fired in single mode. This is just necessary for cleanup procedures and provides a uniform user API independently of the event mode. Calling <a class="el" href="classSmartACE_1_1EventClient.html#aa3a2ade0d5d62129f5846a9b61f72c47" title="Deactivate the event with the specified identifier. ">deactivate()</a> while there are blocking calls aborts them with the appropriate status code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>of event to be disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is ok and event is deactivated</li>
<li>SMART_WRONGID : there is no active event available with this id</li>
<li>SMART_ERROR_COMMUNICATION : communication problems, event not deactivated</li>
<li>SMART_ERROR : something went wrong, event not deactivated</li>
</ul>
</dd></dl>
<p>(Hint: can not return SMART_DISCONNECTED since then each event is for sure also deactivated resulting in SMART_WRONGID) </p>

</div>
</div>
<a id="a714b56aeb5c0dc7b76383fb0a3f8850f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714b56aeb5c0dc7b76383fb0a3f8850f">&#9670;&nbsp;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1EventClient.html">SmartACE::EventClient</a>&lt; P, E &gt;::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect the service requestor from the service provider. </p>
<p>All blocking calls are aborted with the SMART_DISCONNECTED status code. All events are deactivated.</p>
<p>It is no problem to change the connection to a service provider at any point of time irrespective of any calls to <a class="el" href="classSmartACE_1_1EventClient.html#a63dfe22ff6a226e45224df5813d10d7e" title="Check whether event has already fired and return immediately with status information. ">tryEvent()</a> / <a class="el" href="classSmartACE_1_1EventClient.html#a61622ed543663bd4e839dd77a9851cb3" title="Blocking call which waits for the event to fire and then consumes the event. ">getEvent()</a> or <a class="el" href="classSmartACE_1_1EventClient.html#a05da852031c68725906c612b267e69c2" title="Blocking call which waits for the next event. ">getNextEvent()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is OK and service requestor is disconnected from the service provider.</li>
<li>SMART_ERROR_COMMUNICATION : something went wrong at the level of the intercomponent communication. At least the service requestor is in the disconnected state irrespective of the service provider side clean up procedures.</li>
<li>SMART_ERROR : something went wrong. Again at least the service requestor is in the disconnected state. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a61622ed543663bd4e839dd77a9851cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61622ed543663bd4e839dd77a9851cb3">&#9670;&nbsp;</a></span>getEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1EventClient.html">SmartACE::EventClient</a>&lt; P, E &gt;::getEvent </td>
          <td>(</td>
          <td class="paramtype">const Smart::EventIdPtr&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Smart::Duration &amp;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>Smart::Duration::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking call which waits for the event to fire and then consumes the event. </p>
<p>This method consumes an event. Returns immediately if an unconsumed event is available. Blocks otherwise till event becomes available. If method is called concurrently from several threads with the same <em>id</em> and method is blocking, then every call returns with the same <em>event</em> once the event fired. If there is however already an unconsumed event available, then only one out of the concurrent calls consumes the event and the other calls return with appropriate status codes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>of the event activation </td></tr>
    <tr><td class="paramname">event</td><td>is set to the returned event if fired (Communication Object) </td></tr>
    <tr><td class="paramname">timeout</td><td>the optional maximum waiting time for an event (default value max: method blocks indefinitely)</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><b>single mode</b>: </li>
</ul>
<p>Since an event in single mode fires only once, return immediately if the event is already consumed. Also return immediately with an available and unconsumed event and consume it. Otherwise wait until the event fires. </p>
<p><b>Returns status code</b>: </p>
<ul>
<li>SMART_OK : event fired and event is consumed and returned.</li>
<li>SMART_PASSIVE : event fired and got consumed already. Returns immediately without valid event since it can not fire again in single mode.</li>
<li>SMART_CANCELLED : waiting for the event to fire has been aborted or blocking is not not allowed anymore. Therefore no valid <em>event</em> is returned.</li>
<li>SMART_DISCONNECTED : client is disconnected or got disconnected while waiting and therefore no valid <em>event</em> is returned and the activation identifier <em>id</em> is also not valid any longer due to automatic deactivation.</li>
<li>SMART_NOTACTIVATED : got deactivated while waiting and therefore <em>event</em> not valid and also <em>id</em> not valid any longer.</li>
<li>SMART_WRONGID : there is no activation available with this <em>id</em> and therefore <em>event</em> not valid. </li>
</ul>
<ul>
<li><b>continuous mode</b>: </li>
</ul>
<p>Returns immediately if an unconsumed event is available. Returns the newest unconsumed event since activation. Otherwise waits until the event fires again. </p>
<p><b>Returns status code</b>: </p>
<ul>
<li>SMART_OK : unconsumed event is available and event is consumed and returned. Due to the overwriting behavior, only the latest event is available.</li>
<li>SMART_CANCELLED : blocking is not allowed anymore therefore blocking call has been aborted and <em>event</em> is not valid.</li>
<li>SMART_DISCONNECTED : got disconnected while waiting and therefore <em>event</em> not valid and also <em>id</em> not valid any longer due to automatic deactivation.</li>
<li>SMART_NOTACTIVATED : got deactivated while waiting and therefore <em>event</em> not valid and also <em>id</em> not valid any longer.</li>
<li>SMART_WRONGID : there is no activation available with this <em>id</em> and therefore <em>event</em> not valid. </li>
</ul>

</div>
</div>
<a id="a05da852031c68725906c612b267e69c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05da852031c68725906c612b267e69c2">&#9670;&nbsp;</a></span>getNextEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1EventClient.html">SmartACE::EventClient</a>&lt; P, E &gt;::getNextEvent </td>
          <td>(</td>
          <td class="paramtype">const Smart::EventIdPtr&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Smart::Duration &amp;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>Smart::Duration::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking call which waits for the next event. </p>
<p>This methods waits for the <em>next</em> arriving event to make sure that only events arriving after entering the method are considered. Method consumes event. An old event that has been fired is ignored (in contrary to <a class="el" href="classSmartACE_1_1EventClient.html#a61622ed543663bd4e839dd77a9851cb3" title="Blocking call which waits for the event to fire and then consumes the event. ">getEvent()</a>). If method is called concurrently from several threads with the same <em>id</em>, then every call returns with the same <em>event</em> once the event fired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>of the event activation </td></tr>
    <tr><td class="paramname">event</td><td>is set to the returned event if fired (Communication Object) </td></tr>
    <tr><td class="paramname">timeout</td><td>the optional maximum waiting time for an event (default value max: method blocks indefinitely)</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><b>single mode</b>: </li>
</ul>
<p>In single mode one misses the event if it fired before entering this member function. </p>
<p><b>Returns status code</b>: </p>
<ul>
<li>SMART_OK : event fired while waiting for the event and event is consumed and returned</li>
<li>SMART_PASSIVE : event already fired between activation and calling this member function and is therefore missed or event has already been consumed and can not fire again in single mode. Does not block indefinitely and returns no valid <em>event</em>.</li>
<li>SMART_CANCELLED : event not yet fired and waiting for the event has been aborted or blocking is not allowed anymore. No valid <em>event</em> is returned.</li>
<li>SMART_DISCONNECTED : got disconnected while waiting and therefore <em>event</em> not valid and also <em>id</em> not valid any longer due to automatic deactivation.</li>
<li>SMART_NOTACTIVATED : got deactivated while waiting and therefore <em>event</em> not valid and also <em>id</em> not valid any longer.</li>
<li>SMART_WRONGID : there is no activation available with this <em>id</em> and therefore <em>event</em> not valid. </li>
</ul>
<ul>
<li><b>continuous mode</b>: </li>
</ul>
<p>Makes sure that only events fired after entering this member function are considered. </p>
<p><b>Returns status code</b>: </p>
<ul>
<li>SMART_OK : event fired while waiting for the event and event is consumed and returned</li>
<li>SMART_CANCELLED : waiting for the next event has been aborted or blocking is not allowed anymore. No valid <em>event</em> is returned.</li>
<li>SMART_DISCONNECTED : got disconnected while waiting and therefore <em>event</em> not valid and also <em>id</em> not valid any longer due to automatic deactivation.</li>
<li>SMART_NOTACTIVATED : got deactivated while waiting and therefore <em>event</em> not valid and also <em>id</em> not valid any longer.</li>
<li>SMART_WRONGID : there is no activation available with this <em>id</em> and therefore <em>event</em> not valid. </li>
</ul>

</div>
</div>
<a id="adf4056043ecafd37901fc19784c9d025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4056043ecafd37901fc19784c9d025">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1EventClient.html">SmartACE::EventClient</a>&lt; P, E &gt;::remove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove this service requestor from the set of ports wireable via the wiring pattern from outside the component. </p>
<p>Already established connections keep valid but can now be changed only from inside and not from outside this component anymore.</p>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is OK and instance not exposed as port anymore (or was not registered as port).</li>
<li>SMART_ERROR : something went wrong but this instance is removed from the set of ports in any case. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a63dfe22ff6a226e45224df5813d10d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63dfe22ff6a226e45224df5813d10d7e">&#9670;&nbsp;</a></span>tryEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1EventClient.html">SmartACE::EventClient</a>&lt; P, E &gt;::tryEvent </td>
          <td>(</td>
          <td class="paramtype">const Smart::EventIdPtr&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether event has already fired and return immediately with status information. </p>
<p>This method does not consume an available event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>of the event activation to be checked</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>single mode:<ul>
<li>SMART_OK : event fired already, is still available and can be consumed by calling <a class="el" href="classSmartACE_1_1EventClient.html#a61622ed543663bd4e839dd77a9851cb3" title="Blocking call which waits for the event to fire and then consumes the event. ">getEvent()</a>,</li>
<li>SMART_ACTIVE : event has not yet fired</li>
<li>SMART_PASSIVE : event fired already and is already consumed.</li>
<li>SMART_WRONGID : there is no activation available with this <em>id</em></li>
</ul>
</li>
<li>continuous mode:<ul>
<li>SMART_OK : unconsumed event is available. Since events are overwritten this means that at least one new event has been received since the last event consumption.</li>
<li>SMART_ACTIVE : currently there is no unconsumed event available.</li>
<li>SMART_WRONGID : there is no activation available with this <em>id</em> </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>smartEvent.hh</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
