<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AceSmartSoft API Documentation: SmartACE::StateMaster Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AceSmartSoft API Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSmartACE.html">SmartACE</a></li><li class="navelem"><a class="el" href="classSmartACE_1_1StateMaster.html">StateMaster</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSmartACE_1_1StateMaster-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SmartACE::StateMaster Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Master part of state pattern.  
 <a href="classSmartACE_1_1StateMaster.html#details">More...</a></p>

<p><code>#include &lt;smartState.hh&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2c417648e4ab3befb8415659824f33c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1StateMaster.html#a2c417648e4ab3befb8415659824f33c1">StateMaster</a> (<a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *component)</td></tr>
<tr class="memdesc:a2c417648e4ab3befb8415659824f33c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor (not wired with service provider and not exposed as port).  <a href="#a2c417648e4ab3befb8415659824f33c1">More...</a><br /></td></tr>
<tr class="separator:a2c417648e4ab3befb8415659824f33c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d6205c760ca990856f0a400fe60671"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1StateMaster.html#a69d6205c760ca990856f0a400fe60671">~StateMaster</a> ()</td></tr>
<tr class="memdesc:a69d6205c760ca990856f0a400fe60671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a69d6205c760ca990856f0a400fe60671">More...</a><br /></td></tr>
<tr class="separator:a69d6205c760ca990856f0a400fe60671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8819249a2a0d8816b8ee33d30552f1ef"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1StateMaster.html#a8819249a2a0d8816b8ee33d30552f1ef">blocking</a> (const bool b)</td></tr>
<tr class="memdesc:a8819249a2a0d8816b8ee33d30552f1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow or abort and reject blocking calls.  <a href="#a8819249a2a0d8816b8ee33d30552f1ef">More...</a><br /></td></tr>
<tr class="separator:a8819249a2a0d8816b8ee33d30552f1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c09364d3150198339abe3328709bf8"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1StateMaster.html#ad3c09364d3150198339abe3328709bf8">setWaitState</a> (const std::string &amp;state, const std::string &amp;server, const std::string &amp;service=&quot;state&quot;)</td></tr>
<tr class="memdesc:ad3c09364d3150198339abe3328709bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking call to change the main state.  <a href="#ad3c09364d3150198339abe3328709bf8">More...</a><br /></td></tr>
<tr class="separator:ad3c09364d3150198339abe3328709bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4274e1bdc9b54ec875fbc9584d7e143"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1StateMaster.html#aa4274e1bdc9b54ec875fbc9584d7e143">getCurrentMainState</a> (std::string &amp;MainState, const std::string &amp;server, const std::string &amp;service=&quot;state&quot;)</td></tr>
<tr class="memdesc:aa4274e1bdc9b54ec875fbc9584d7e143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking call which returns the currently active main state.  <a href="#aa4274e1bdc9b54ec875fbc9584d7e143">More...</a><br /></td></tr>
<tr class="separator:aa4274e1bdc9b54ec875fbc9584d7e143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4f4c8f356e03b132ed5ba051b42c84"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1StateMaster.html#aeb4f4c8f356e03b132ed5ba051b42c84">getAllMainStates</a> (std::list&lt; std::string &gt; &amp;MainStates, const std::string &amp;server, const std::string &amp;service=&quot;state&quot;)</td></tr>
<tr class="memdesc:aeb4f4c8f356e03b132ed5ba051b42c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking call which returns a list of valid main states.  <a href="#aeb4f4c8f356e03b132ed5ba051b42c84">More...</a><br /></td></tr>
<tr class="separator:aeb4f4c8f356e03b132ed5ba051b42c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f84e36bc2e7eb12097878769b955ab"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1StateMaster.html#a99f84e36bc2e7eb12097878769b955ab">getSubStates</a> (const std::string &amp;MainState, std::list&lt; std::string &gt; &amp;SubStates, const std::string &amp;server, const std::string &amp;service=&quot;state&quot;)</td></tr>
<tr class="memdesc:a99f84e36bc2e7eb12097878769b955ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking call which returns a list of substates assigned to the specified main state.  <a href="#a99f84e36bc2e7eb12097878769b955ab">More...</a><br /></td></tr>
<tr class="separator:a99f84e36bc2e7eb12097878769b955ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Master part of state pattern. </p>
<p>The configuration class provides priorized mutexes for protecting configurations. Normally, a complex robotic system requires a lot of different components which can not all run at the same time. Depending on the current task to be executed and depending on the available ressources, one has to be able to activate and deactivate components and activities within components. One the one hand deactivation should be done in such a way that the component can perform cleanup tasks. On the other hand a component must still be interruptable even if it is pending in a blocking call because the corresponding server has already been deactivated.</p>
<p>The configuration class therefore provides mechanisms for graceful activation and deactivation of sets of activities within components.</p>
<p>As is explained in the specification of the state pattern, one can activate one mainstate at a time. A mainstate can however comprise several substates which are all active at the same time. A master can only set mainstates whereas the slave can only acquire substates. This allows the simple management of sets of concurrent activities.</p>
<p>For a complete description see the printed documentation and further details in <a href="/drupal/?q=node/51#third-example">third example</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2c417648e4ab3befb8415659824f33c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c417648e4ab3befb8415659824f33c1">&#9670;&nbsp;</a></span>StateMaster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SmartACE::StateMaster::StateMaster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor (not wired with service provider and not exposed as port). </p>
<p>add()/remove() and connect()/disconnect() can always be used to change the status of the instance. Instance is not connected to a service provider and is not exposed as port wireable from outside the component.</p>
<p>(Currently exception not thrown)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>management class of the component </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69d6205c760ca990856f0a400fe60671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d6205c760ca990856f0a400fe60671">&#9670;&nbsp;</a></span>~StateMaster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SmartACE::StateMaster::~StateMaster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8819249a2a0d8816b8ee33d30552f1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8819249a2a0d8816b8ee33d30552f1ef">&#9670;&nbsp;</a></span>blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode SmartACE::StateMaster::blocking </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow or abort and reject blocking calls. </p>
<p>If blocking is set to false all blocking calls return with SMART_CANCELLED. This can be used to abort blocking calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>(blocking) true/false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : new mode set</li>
<li>SMART_ERROR : something went wrong </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aeb4f4c8f356e03b132ed5ba051b42c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4f4c8f356e03b132ed5ba051b42c84">&#9670;&nbsp;</a></span>getAllMainStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode SmartACE::StateMaster::getAllMainStates </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>MainStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service</em> = <code>&quot;state&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking call which returns a list of valid main states. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MainStates</td><td>contain all valid main states of the server (slave) </td></tr>
    <tr><td class="paramname">server</td><td>allows to define the slave from which all the mainstates are returned </td></tr>
    <tr><td class="paramname">service</td><td>is an optional parameter in case the slave has a different service name than "state" (mostly for backwards compatibility)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is ok</li>
<li>SMART_NOTACTIVATED : state object of server component not yet activated</li>
<li>SMART_ERROR_COMMUNICATION : communication problems</li>
<li>SMART_ERROR : something went wrong</li>
<li>(hint for experts: SMART_CANCELLED can not be returned since a component can always return its list of mainstates even if it is disabled. Therefore there is no need to abort this method call when a request to reach the neutral state is pending) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa4274e1bdc9b54ec875fbc9584d7e143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4274e1bdc9b54ec875fbc9584d7e143">&#9670;&nbsp;</a></span>getCurrentMainState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode SmartACE::StateMaster::getCurrentMainState </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>MainState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service</em> = <code>&quot;state&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking call which returns the currently active main state. </p>
<p>Is only for convenience and is not necessary since the master always knows what has been configured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MainState</td><td>is set to the current main state as returned by the server (slave) </td></tr>
    <tr><td class="paramname">server</td><td>allows to define the slave from which the currently active mainstate is returned </td></tr>
    <tr><td class="paramname">service</td><td>is an optional parameter in case the slave has a different service name than "state" (mostly for backwards compatibility)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is ok</li>
<li>SMART_NOTACTIVATED : state object of server component not yet activated</li>
<li>SMART_ERROR_COMMUNICATION : communication problems</li>
<li>SMART_ERROR : something went wrong</li>
<li>(hint for experts: SMART_CANCELLED can not be returned since a component can always return its current state even if it is disabled. Therefore there is no need to abort this method call when a request to reach the neutral state is pending) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a99f84e36bc2e7eb12097878769b955ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f84e36bc2e7eb12097878769b955ab">&#9670;&nbsp;</a></span>getSubStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode SmartACE::StateMaster::getSubStates </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>MainState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>SubStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service</em> = <code>&quot;state&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking call which returns a list of substates assigned to the specified main state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MainState</td><td>is the mainstate to which we want to get the list of substates </td></tr>
    <tr><td class="paramname">SubStates</td><td>is set to the returned list of substates </td></tr>
    <tr><td class="paramname">server</td><td>allows to define the slave from which all the substates (for the given mainstate) are returned </td></tr>
    <tr><td class="paramname">service</td><td>is an optional parameter in case the slave has a different service name than "state" (mostly for backwards compatibility)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is ok</li>
<li>SMART_NOTACTIVATED : state object of server component not yet activated</li>
<li>SMART_UNKNOWNSTATE : the main state asked for is unknown</li>
<li>SMART_ERROR_COMMUNICATION : communication problems</li>
<li>SMART_ERROR : something went wrong</li>
<li>(hint for experts: SMART_CANCELLED can not be returned since a component can always return its list of mainstates even if it is disabled. Therefore there is no need to abort this method call when a request to reach the neutral state is pending) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad3c09364d3150198339abe3328709bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c09364d3150198339abe3328709bf8">&#9670;&nbsp;</a></span>setWaitState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode SmartACE::StateMaster::setWaitState </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service</em> = <code>&quot;state&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking call to change the main state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td><ul>
<li>If "Deactivated" is specified as main state, every blocking query etc. is aborted with SMART_CANCELLED to reach the "neutral" state as fast as possible.</li>
<li>If "Neutral" is specified the neutral state will be reached without aborting pending communication calls. </li>
</ul>
</td></tr>
    <tr><td class="paramname">server</td><td>allows to define the slave for the state-change </td></tr>
    <tr><td class="paramname">service</td><td>is an optional parameter in case the slave has a different service name than "state" (mostly for backwards compatibility)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is ok</li>
<li>SMART_UNKNOWNSTATE : requested mainstate is unknown and therefore no state change has been performed</li>
<li>SMART_NOTACTIVATED : state object of server component not yet activated</li>
<li>SMART_CANCELLED : component has been requested to reach neutral state, therefore pending setWaitState has been aborted</li>
<li>SMART_ERROR_COMMUNICATION : communication problems</li>
<li>SMART_ERROR : something went wrong </li>
</ul>
</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>smartState.hh</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
