<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AceSmartSoft API Documentation: SmartACE::PushClient&lt; DataType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AceSmartSoft API Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSmartACE.html">SmartACE</a></li><li class="navelem"><a class="el" href="classSmartACE_1_1PushClient.html">PushClient</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSmartACE_1_1PushClient-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SmartACE::PushClient&lt; DataType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Client part of the Push pattern to provide a flexible push service.  
 <a href="classSmartACE_1_1PushClient.html#details">More...</a></p>

<p><code>#include &lt;smartPush.hh&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SmartACE::PushClient&lt; DataType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSmartACE_1_1PushClient.png" usemap="#SmartACE::PushClient_3C_20DataType_20_3E_map" alt=""/>
  <map id="SmartACE::PushClient_3C_20DataType_20_3E_map" name="SmartACE::PushClient_3C_20DataType_20_3E_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0b3fb50d767c0d2e5c3e855c92c93750"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1PushClient.html#a0b3fb50d767c0d2e5c3e855c92c93750">PushClient</a> (<a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *component, const std::string &amp;port, <a class="el" href="classSmartACE_1_1WiringSlave.html">WiringSlave</a> *slave)</td></tr>
<tr class="memdesc:a0b3fb50d767c0d2e5c3e855c92c93750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor (exposed as port and wireable from outside by other components).  <a href="#a0b3fb50d767c0d2e5c3e855c92c93750">More...</a><br /></td></tr>
<tr class="separator:a0b3fb50d767c0d2e5c3e855c92c93750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc10038c2518d65ee99c779ee2a3137e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1PushClient.html#afc10038c2518d65ee99c779ee2a3137e">PushClient</a> (<a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *component)</td></tr>
<tr class="memdesc:afc10038c2518d65ee99c779ee2a3137e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor (not wired with service provider and not exposed as port).  <a href="#afc10038c2518d65ee99c779ee2a3137e">More...</a><br /></td></tr>
<tr class="separator:afc10038c2518d65ee99c779ee2a3137e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7aec6ded073500b4b29a9d4c10d74f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1PushClient.html#a9e7aec6ded073500b4b29a9d4c10d74f">PushClient</a> (<a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *component, const std::string &amp;server, const std::string &amp;service)</td></tr>
<tr class="memdesc:a9e7aec6ded073500b4b29a9d4c10d74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor (wired with specified service provider).  <a href="#a9e7aec6ded073500b4b29a9d4c10d74f">More...</a><br /></td></tr>
<tr class="separator:a9e7aec6ded073500b4b29a9d4c10d74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46676c6d217445377bfbfcf9e687c4bd"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1PushClient.html#a46676c6d217445377bfbfcf9e687c4bd">~PushClient</a> ()</td></tr>
<tr class="memdesc:a46676c6d217445377bfbfcf9e687c4bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a46676c6d217445377bfbfcf9e687c4bd">More...</a><br /></td></tr>
<tr class="separator:a46676c6d217445377bfbfcf9e687c4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ef7001b2b9396b9bbdb334dfa34ac1"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1PushClient.html#a83ef7001b2b9396b9bbdb334dfa34ac1">add</a> (<a class="el" href="classSmartACE_1_1WiringSlave.html">WiringSlave</a> *slave, const std::string &amp;port)</td></tr>
<tr class="memdesc:a83ef7001b2b9396b9bbdb334dfa34ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add this instance to the set of ports wireable via the wiring pattern from outside the component.  <a href="#a83ef7001b2b9396b9bbdb334dfa34ac1">More...</a><br /></td></tr>
<tr class="separator:a83ef7001b2b9396b9bbdb334dfa34ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419dc9a0cec9ebb08ceb9be26224c355"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1PushClient.html#a419dc9a0cec9ebb08ceb9be26224c355">remove</a> ()</td></tr>
<tr class="memdesc:a419dc9a0cec9ebb08ceb9be26224c355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove this service requestor from the set of ports wireable via the wiring pattern from outside the component.  <a href="#a419dc9a0cec9ebb08ceb9be26224c355">More...</a><br /></td></tr>
<tr class="separator:a419dc9a0cec9ebb08ceb9be26224c355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc2809a8fe1f34983fe84d7f1bf7336"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1PushClient.html#a1cc2809a8fe1f34983fe84d7f1bf7336">connect</a> (const std::string &amp;server, const std::string &amp;service)</td></tr>
<tr class="memdesc:a1cc2809a8fe1f34983fe84d7f1bf7336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect this service requestor to the denoted service provider.  <a href="#a1cc2809a8fe1f34983fe84d7f1bf7336">More...</a><br /></td></tr>
<tr class="separator:a1cc2809a8fe1f34983fe84d7f1bf7336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cdd1b46ff74fe6efe169c32fb812e8"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1PushClient.html#ac0cdd1b46ff74fe6efe169c32fb812e8">disconnect</a> ()</td></tr>
<tr class="memdesc:ac0cdd1b46ff74fe6efe169c32fb812e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect the service requestor from the service provider.  <a href="#ac0cdd1b46ff74fe6efe169c32fb812e8">More...</a><br /></td></tr>
<tr class="separator:ac0cdd1b46ff74fe6efe169c32fb812e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50eb6a0838b37d251cc22417f78ee6f"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1PushClient.html#ad50eb6a0838b37d251cc22417f78ee6f">subscribe</a> (const int &amp;prescale=1)</td></tr>
<tr class="memdesc:ad50eb6a0838b37d251cc22417f78ee6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe at the server to periodically get every n-th update.  <a href="#ad50eb6a0838b37d251cc22417f78ee6f">More...</a><br /></td></tr>
<tr class="separator:ad50eb6a0838b37d251cc22417f78ee6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ff7cacfd3b3f1838bb085791afc9c8"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1PushClient.html#a44ff7cacfd3b3f1838bb085791afc9c8">unsubscribe</a> ()</td></tr>
<tr class="memdesc:a44ff7cacfd3b3f1838bb085791afc9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe to get no more updates.  <a href="#a44ff7cacfd3b3f1838bb085791afc9c8">More...</a><br /></td></tr>
<tr class="separator:a44ff7cacfd3b3f1838bb085791afc9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4ecfe0c80dd54eea4174fa783c1cfe"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1PushClient.html#afa4ecfe0c80dd54eea4174fa783c1cfe">blocking</a> (const bool b)</td></tr>
<tr class="memdesc:afa4ecfe0c80dd54eea4174fa783c1cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow or abort and reject blocking calls.  <a href="#afa4ecfe0c80dd54eea4174fa783c1cfe">More...</a><br /></td></tr>
<tr class="separator:afa4ecfe0c80dd54eea4174fa783c1cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a350612004d1d1b9096c2e37b77dbbf"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1PushClient.html#a6a350612004d1d1b9096c2e37b77dbbf">getUpdate</a> (DataType &amp;d)</td></tr>
<tr class="memdesc:a6a350612004d1d1b9096c2e37b77dbbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking call to immediately return the latest available data buffered at the client side from the most recent update.  <a href="#a6a350612004d1d1b9096c2e37b77dbbf">More...</a><br /></td></tr>
<tr class="separator:a6a350612004d1d1b9096c2e37b77dbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b146c163344e391f71777bc06e1dff"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1PushClient.html#ab4b146c163344e391f71777bc06e1dff">getUpdateWait</a> (DataType &amp;d, const std::chrono::steady_clock::duration &amp;timeout=std::chrono::steady_clock::duration::zero())</td></tr>
<tr class="memdesc:ab4b146c163344e391f71777bc06e1dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking call which waits until the next update is received.  <a href="#ab4b146c163344e391f71777bc06e1dff">More...</a><br /></td></tr>
<tr class="separator:ab4b146c163344e391f71777bc06e1dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab2db7beb0ccde9d121eddc964629b1"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1PushClient.html#adab2db7beb0ccde9d121eddc964629b1">getServerInfo</a> (<a class="el" href="namespaceSmartACE.html#ad07f92a3e28489a6b04d1b30b9953f20">SmartTimeValue</a> &amp;t, bool &amp;r)</td></tr>
<tr class="memdesc:adab2db7beb0ccde9d121eddc964629b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cycle time and server state.  <a href="#adab2db7beb0ccde9d121eddc964629b1">More...</a><br /></td></tr>
<tr class="separator:adab2db7beb0ccde9d121eddc964629b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class DataType&gt;<br />
class SmartACE::PushClient&lt; DataType &gt;</h3>

<p>Client part of the Push pattern to provide a flexible push service. </p>
<p>Clients can subscribe to regularly get every n-th update. This class implements the Subject part of the Observer design pattern (see also PushClientObserver class).</p>
<p>Template parameters</p><ul>
<li><b>T</b>: Pushed value class (Communication Object)</li>
</ul>
<p>Demonstrated in <a href="/drupal/?q=node/51#eigth-example">eigth example</a> </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0b3fb50d767c0d2e5c3e855c92c93750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3fb50d767c0d2e5c3e855c92c93750">&#9670;&nbsp;</a></span>PushClient() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartACE_1_1PushClient.html">SmartACE::PushClient</a>&lt; DataType &gt;::<a class="el" href="classSmartACE_1_1PushClient.html">PushClient</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSmartACE_1_1WiringSlave.html">WiringSlave</a> *&#160;</td>
          <td class="paramname"><em>slave</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor (exposed as port and wireable from outside by other components). </p>
<p><a class="el" href="classSmartACE_1_1PushClient.html#a83ef7001b2b9396b9bbdb334dfa34ac1" title="Add this instance to the set of ports wireable via the wiring pattern from outside the component...">add()</a>/remove() and <a class="el" href="classSmartACE_1_1PushClient.html#a1cc2809a8fe1f34983fe84d7f1bf7336" title="Connect this service requestor to the denoted service provider. ">connect()</a>/disconnect() can always be used to change the status of the instance. Instance is not connected to a service provider.</p>
<p>Throws exception if port name is already in use.</p><ul>
<li>SMART_PORTALREADYUSED : port name already in use, instance not created</li>
<li>SMART_ERROR : something went wrong, instance not created</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>management class of the component </td></tr>
    <tr><td class="paramname">port</td><td>name of the client-port (visible in <em>wiring-slave</em>) </td></tr>
    <tr><td class="paramname">slave</td><td>reference to wiring-slave </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc10038c2518d65ee99c779ee2a3137e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc10038c2518d65ee99c779ee2a3137e">&#9670;&nbsp;</a></span>PushClient() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartACE_1_1PushClient.html">SmartACE::PushClient</a>&lt; DataType &gt;::<a class="el" href="classSmartACE_1_1PushClient.html">PushClient</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor (not wired with service provider and not exposed as port). </p>
<p><a class="el" href="classSmartACE_1_1PushClient.html#a83ef7001b2b9396b9bbdb334dfa34ac1" title="Add this instance to the set of ports wireable via the wiring pattern from outside the component...">add()</a>/remove() and <a class="el" href="classSmartACE_1_1PushClient.html#a1cc2809a8fe1f34983fe84d7f1bf7336" title="Connect this service requestor to the denoted service provider. ">connect()</a>/disconnect() can always be used to change the status of the instance. Instance is not connected to a service provider and is not exposed as port wireable from outside the component.</p>
<p>(Currently exception not thrown)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>management class of the component </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e7aec6ded073500b4b29a9d4c10d74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7aec6ded073500b4b29a9d4c10d74f">&#9670;&nbsp;</a></span>PushClient() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartACE_1_1PushClient.html">SmartACE::PushClient</a>&lt; DataType &gt;::<a class="el" href="classSmartACE_1_1PushClient.html">PushClient</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor (wired with specified service provider). </p>
<p>Connects to the denoted service and blocks until the connection has been established. Blocks infinitely if denoted service becomes not available since constructor performs retries. Blocking is useful to simplify startup of components which have mutual dependencies. <a class="el" href="classSmartACE_1_1PushClient.html#a83ef7001b2b9396b9bbdb334dfa34ac1" title="Add this instance to the set of ports wireable via the wiring pattern from outside the component...">add()</a>/remove() and <a class="el" href="classSmartACE_1_1PushClient.html#a1cc2809a8fe1f34983fe84d7f1bf7336" title="Connect this service requestor to the denoted service provider. ">connect()</a>/disconnect() can always be used to change the status of the instance.</p>
<p>Throws exception if denoted service is incompatible (wrong communication pattern or wrong communication objects).</p><ul>
<li>SMART_INCOMPATIBLESERVICE : the denoted service is incompatible (wrong communication pattern or wrong communication objects) and can therefore not be connected. Instance is not created.</li>
<li>SMART_ERROR : something went wrong, instance not created</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>management class of the component </td></tr>
    <tr><td class="paramname">server</td><td>name of the server </td></tr>
    <tr><td class="paramname">service</td><td>name of the service </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46676c6d217445377bfbfcf9e687c4bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46676c6d217445377bfbfcf9e687c4bd">&#9670;&nbsp;</a></span>~PushClient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSmartACE_1_1PushClient.html">SmartACE::PushClient</a>&lt; DataType &gt;::~<a class="el" href="classSmartACE_1_1PushClient.html">PushClient</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>The destructor calls <a class="el" href="classSmartACE_1_1PushClient.html#a419dc9a0cec9ebb08ceb9be26224c355" title="Remove this service requestor from the set of ports wireable via the wiring pattern from outside the ...">remove()</a> and <a class="el" href="classSmartACE_1_1PushClient.html#ac0cdd1b46ff74fe6efe169c32fb812e8" title="Disconnect the service requestor from the service provider. ">disconnect()</a> and therefore properly cleans up every pending data reception and removes the instance from the set of wireable ports. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a83ef7001b2b9396b9bbdb334dfa34ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ef7001b2b9396b9bbdb334dfa34ac1">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1PushClient.html">SmartACE::PushClient</a>&lt; DataType &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSmartACE_1_1WiringSlave.html">WiringSlave</a> *&#160;</td>
          <td class="paramname"><em>slave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add this instance to the set of ports wireable via the wiring pattern from outside the component. </p>
<p>Already established connections keep valid. If this service requestor is already exposed as port, it is first removed and then added with the new port name. <a class="el" href="classSmartACE_1_1PushClient.html#a83ef7001b2b9396b9bbdb334dfa34ac1" title="Add this instance to the set of ports wireable via the wiring pattern from outside the component...">add()</a>/remove() and <a class="el" href="classSmartACE_1_1PushClient.html#a1cc2809a8fe1f34983fe84d7f1bf7336" title="Connect this service requestor to the denoted service provider. ">connect()</a>/disconnect() can always be used to change the status of this instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slave</td><td>wiring slave of this component </td></tr>
    <tr><td class="paramname">port</td><td>name of port used for wiring</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is OK and this instance added to the set of ports wireable from outside the component</li>
<li>SMART_PORTALREADYUSED : port name already in use and this instance now not available as port</li>
<li>SMART_ERROR : something went wrong </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afa4ecfe0c80dd54eea4174fa783c1cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa4ecfe0c80dd54eea4174fa783c1cfe">&#9670;&nbsp;</a></span>blocking()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1PushClient.html">SmartACE::PushClient</a>&lt; DataType &gt;::blocking </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow or abort and reject blocking calls. </p>
<p>If blocking is set to false all blocking calls return with SMART_CANCELLED. This can be used to abort blocking calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>(blocking) true/false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : new mode set</li>
<li>SMART_ERROR : something went wrong </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1cc2809a8fe1f34983fe84d7f1bf7336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc2809a8fe1f34983fe84d7f1bf7336">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1PushClient.html">SmartACE::PushClient</a>&lt; DataType &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect this service requestor to the denoted service provider. </p>
<p>An already established connection is first disconnected. See <a class="el" href="classSmartACE_1_1PushClient.html#ac0cdd1b46ff74fe6efe169c32fb812e8" title="Disconnect the service requestor from the service provider. ">disconnect()</a> for implications on pending data reception in that case.</p>
<p>It is no problem to change the connection to a service provider at any point of time irrespective of any calls to <a class="el" href="classSmartACE_1_1PushClient.html#a6a350612004d1d1b9096c2e37b77dbbf" title="Non-blocking call to immediately return the latest available data buffered at the client side from th...">getUpdate()</a> / <a class="el" href="classSmartACE_1_1PushClient.html#ab4b146c163344e391f71777bc06e1dff" title="Blocking call which waits until the next update is received. ">getUpdateWait()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">server</td><td>name of the server </td></tr>
    <tr><td class="paramname">service</td><td>name of the service</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is OK and connected to the specified service.</li>
<li>SMART_SERVICEUNAVAILABLE : the specified service is currently not available and the requested connection can not be established. Service requestor is now not connected to any service provider.</li>
<li>SMART_INCOMPATIBLESERVICE : the specified service provider is not compatible (wrong communication pattern or wrong communication objects) to this service requestor and can therefore not be connected. Service requestor is now not connected to any service provider.</li>
<li>SMART_ERROR_COMMUNICATION : communication problems, service requestor is now not connected to any service provider.</li>
<li>SMART_ERROR : something went wrong, service requestor is now not connected to any service provider. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac0cdd1b46ff74fe6efe169c32fb812e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cdd1b46ff74fe6efe169c32fb812e8">&#9670;&nbsp;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1PushClient.html">SmartACE::PushClient</a>&lt; DataType &gt;::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect the service requestor from the service provider. </p>
<p>A disconnect always first performs an unsubscribe. See unsubsribe() for implications on <a class="el" href="classSmartACE_1_1PushClient.html#a6a350612004d1d1b9096c2e37b77dbbf" title="Non-blocking call to immediately return the latest available data buffered at the client side from th...">getUpdate()</a> and <a class="el" href="classSmartACE_1_1PushClient.html#ab4b146c163344e391f71777bc06e1dff" title="Blocking call which waits until the next update is received. ">getUpdateWait()</a>.</p>
<p>It is no problem to change the connection to a service provider at any point of time irrespective of any calls to <a class="el" href="classSmartACE_1_1PushClient.html#a6a350612004d1d1b9096c2e37b77dbbf" title="Non-blocking call to immediately return the latest available data buffered at the client side from th...">getUpdate()</a> / <a class="el" href="classSmartACE_1_1PushClient.html#ab4b146c163344e391f71777bc06e1dff" title="Blocking call which waits until the next update is received. ">getUpdateWait()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is OK and service requestor is disconnected from the service provider.</li>
<li>SMART_ERROR_COMMUNICATION : something went wrong at the level of the intercomponent communication. At least the service requestor is in the disconnected state irrespective of the service provider side clean up procedures.</li>
<li>SMART_ERROR : something went wrong. Again at least the service requestor is in the disconnected state. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adab2db7beb0ccde9d121eddc964629b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab2db7beb0ccde9d121eddc964629b1">&#9670;&nbsp;</a></span>getServerInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1PushClient.html">SmartACE::PushClient</a>&lt; DataType &gt;::getServerInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSmartACE.html#ad07f92a3e28489a6b04d1b30b9953f20">SmartTimeValue</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get cycle time and server state. </p>
<p>Returns cycle time of server in [seconds] and server state indicating whether server is activated or not. The client can decide on the cycle time on its individual update rate at subscription.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>is set to the server cycle time [seconds] </td></tr>
    <tr><td class="paramname">r</td><td>indicates whether server is started [true, false]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is ok and returned values are valid.</li>
<li>SMART_DISCONNECTED : client is not connected to a server and therefore not get any valid server info.</li>
<li>SMART_ERROR_COMMUNICATION : communication problems and returned server info is not valid.</li>
<li>SMART_ERROR : something went completely wrong and no valid server info returned. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6a350612004d1d1b9096c2e37b77dbbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a350612004d1d1b9096c2e37b77dbbf">&#9670;&nbsp;</a></span>getUpdate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1PushClient.html">SmartACE::PushClient</a>&lt; DataType &gt;::getUpdate </td>
          <td>(</td>
          <td class="paramtype">DataType &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-blocking call to immediately return the latest available data buffered at the client side from the most recent update. </p>
<p>No data is returned as long as no update is received since subscription. To avoid returning old data, no data is returned after the client is unsubscribed or when the server is not active.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>is set to the newest currently available data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything ok and latest data since client got subscribed is returned.</li>
<li>SMART_NODATA : client has not yet received an update since subscription and therefore no data is available and no data is returned.</li>
<li>SMART_NOTACTIVATED : the server is currently not active and does therefore not provide updates at the expected rate. No valid data returned.</li>
<li>SMART_UNSUBSCRIBED : no data available since client is not subscribed and can therefore not receive updates. Method does not return old data from last subscription since these might be based on too old parameter settings. To get data one has to be subscribed.</li>
<li>SMART_DISCONNECTED : no data returned since client is even not connected to a server.</li>
<li>SMART_ERROR : something went wrong </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab4b146c163344e391f71777bc06e1dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b146c163344e391f71777bc06e1dff">&#9670;&nbsp;</a></span>getUpdateWait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1PushClient.html">SmartACE::PushClient</a>&lt; DataType &gt;::getUpdateWait </td>
          <td>(</td>
          <td class="paramtype">DataType &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::steady_clock::duration &amp;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::steady_clock::duration::zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking call which waits until the next update is received. </p>
<p>Blocking is aborted with the appropriate status if either the server gets deactivated, the client gets unsubscribed or disconnected or if blocking is not allowed any more at the client.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>is set to the newest currently available data </td></tr>
    <tr><td class="paramname">timeout</td><td>allows to release the blocking wait after a given timeout time (the default max_time means infinite blocking)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is ok and just received data is returned.</li>
<li>SMART_CANCELLED : blocking is not allowed or is not allowed anymore. Waiting for the next update is aborted and no valid data is returned.</li>
<li>SMART_NOTACTIVATED : the server is currently not active and does therefore not provide updates at the expected rate. No valid data returned.</li>
<li>SMART_UNSUBSCRIBED : returns immediately without data if the client is not subscribed.</li>
<li>SMART_DISCONNECTED : returns immediately without data since client is even not connected to a server.</li>
<li>SMART_ERROR : something went completely wrong and no valid data returned. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a419dc9a0cec9ebb08ceb9be26224c355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419dc9a0cec9ebb08ceb9be26224c355">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1PushClient.html">SmartACE::PushClient</a>&lt; DataType &gt;::remove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove this service requestor from the set of ports wireable via the wiring pattern from outside the component. </p>
<p>Already established connections keep valid but can now be changed only from inside and not from outside this component anymore.</p>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is OK and instance not exposed as port anymore (or was not registered as port).</li>
<li>SMART_ERROR : something went wrong but this instance is removed from the set of ports in any case. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad50eb6a0838b37d251cc22417f78ee6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50eb6a0838b37d251cc22417f78ee6f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1PushClient.html">SmartACE::PushClient</a>&lt; DataType &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>prescale</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribe at the server to periodically get every n-th update. </p>
<p>A newly subscribed client gets the next available new data and is then updated with regard to its individual update cycle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prescale</td><td>whole-numbered value to set the update rate to every n-th value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is ok and client is subscribed</li>
<li>SMART_DISCONNECTED : client is not connected to a server and can therefore not subscribe for updates, not subscribed</li>
<li>SMART_ERROR_COMMUNICATION : communication problems, not subscribed</li>
<li>SMART_ERROR : something went wrong, not subscribed </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a44ff7cacfd3b3f1838bb085791afc9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ff7cacfd3b3f1838bb085791afc9c8">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1PushClient.html">SmartACE::PushClient</a>&lt; DataType &gt;::unsubscribe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsubscribe to get no more updates. </p>
<p>All blocking calls are aborted with the appropriate status and yet received and still buffered data is deleted to avoid returning old data.</p>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is ok and client is now unsubscribed or has already been unsubscribed</li>
<li>SMART_ERROR_COMMUNICATION : communication problems, not unsubscribed</li>
<li>SMART_ERROR : something went wrong, not unsubscribed</li>
</ul>
</dd></dl>
<p>(can not return SMART_DISCONNECTED since then client is for sure also unsubscribed which results in SMART_OK) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>smartPush.hh</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
