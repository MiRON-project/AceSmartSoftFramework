<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AceSmartSoft API Documentation: SmartACE::QueryClient&lt; R, A &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AceSmartSoft API Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSmartACE.html">SmartACE</a></li><li class="navelem"><a class="el" href="classSmartACE_1_1QueryClient.html">QueryClient</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSmartACE_1_1QueryClient-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SmartACE::QueryClient&lt; R, A &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Client part of query pattern to perform two-way communication.  
 <a href="classSmartACE_1_1QueryClient.html#details">More...</a></p>

<p><code>#include &lt;smartQuery.hh&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SmartACE::QueryClient&lt; R, A &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSmartACE_1_1QueryClient.png" usemap="#SmartACE::QueryClient_3C_20R_2C_20A_20_3E_map" alt=""/>
  <map id="SmartACE::QueryClient_3C_20R_2C_20A_20_3E_map" name="SmartACE::QueryClient_3C_20R_2C_20A_20_3E_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab3bf577d31a71d8d9b842eac6e2f2a5a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1QueryClient.html#ab3bf577d31a71d8d9b842eac6e2f2a5a">QueryClient</a> (<a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *component, const std::string &amp;port, <a class="el" href="classSmartACE_1_1WiringSlave.html">WiringSlave</a> *slave)</td></tr>
<tr class="memdesc:ab3bf577d31a71d8d9b842eac6e2f2a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor (exposed as port and wireable from outside by other components).  <a href="#ab3bf577d31a71d8d9b842eac6e2f2a5a">More...</a><br /></td></tr>
<tr class="separator:ab3bf577d31a71d8d9b842eac6e2f2a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5242cd415d2007b08091fe6c6af6e57d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1QueryClient.html#a5242cd415d2007b08091fe6c6af6e57d">QueryClient</a> (<a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *component)</td></tr>
<tr class="memdesc:a5242cd415d2007b08091fe6c6af6e57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor (not wired with service provider and not exposed as port).  <a href="#a5242cd415d2007b08091fe6c6af6e57d">More...</a><br /></td></tr>
<tr class="separator:a5242cd415d2007b08091fe6c6af6e57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0598729db4c27356a12374fbe9c836"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1QueryClient.html#aff0598729db4c27356a12374fbe9c836">QueryClient</a> (<a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *component, const std::string &amp;server, const std::string &amp;service)</td></tr>
<tr class="memdesc:aff0598729db4c27356a12374fbe9c836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor (wired with specified service provider).  <a href="#aff0598729db4c27356a12374fbe9c836">More...</a><br /></td></tr>
<tr class="separator:aff0598729db4c27356a12374fbe9c836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966cb10cdc3c4935fa9a17183f07595d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1QueryClient.html#a966cb10cdc3c4935fa9a17183f07595d">~QueryClient</a> ()</td></tr>
<tr class="memdesc:a966cb10cdc3c4935fa9a17183f07595d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a966cb10cdc3c4935fa9a17183f07595d">More...</a><br /></td></tr>
<tr class="separator:a966cb10cdc3c4935fa9a17183f07595d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5940a2e3348ad737b72bcf8325fb6c55"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1QueryClient.html#a5940a2e3348ad737b72bcf8325fb6c55">add</a> (<a class="el" href="classSmartACE_1_1WiringSlave.html">WiringSlave</a> *slave, const std::string &amp;port)</td></tr>
<tr class="memdesc:a5940a2e3348ad737b72bcf8325fb6c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add this instance to the set of ports wireable via the wiring pattern from outside the component.  <a href="#a5940a2e3348ad737b72bcf8325fb6c55">More...</a><br /></td></tr>
<tr class="separator:a5940a2e3348ad737b72bcf8325fb6c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac735f9279679952dbf6e6b061d16d00"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1QueryClient.html#aac735f9279679952dbf6e6b061d16d00">remove</a> ()</td></tr>
<tr class="memdesc:aac735f9279679952dbf6e6b061d16d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove this service requestor from the set of ports wireable via the wiring pattern from outside the component.  <a href="#aac735f9279679952dbf6e6b061d16d00">More...</a><br /></td></tr>
<tr class="separator:aac735f9279679952dbf6e6b061d16d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74984bd7e8023f1318c5bdeb4ad1e85d"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1QueryClient.html#a74984bd7e8023f1318c5bdeb4ad1e85d">connect</a> (const std::string &amp;server, const std::string &amp;service)</td></tr>
<tr class="memdesc:a74984bd7e8023f1318c5bdeb4ad1e85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect this service requestor to the denoted service provider.  <a href="#a74984bd7e8023f1318c5bdeb4ad1e85d">More...</a><br /></td></tr>
<tr class="separator:a74984bd7e8023f1318c5bdeb4ad1e85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa999d4616a807f9c0dbc4cf037d5fb1d"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1QueryClient.html#aa999d4616a807f9c0dbc4cf037d5fb1d">disconnect</a> ()</td></tr>
<tr class="memdesc:aa999d4616a807f9c0dbc4cf037d5fb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect the service requestor from the service provider.  <a href="#aa999d4616a807f9c0dbc4cf037d5fb1d">More...</a><br /></td></tr>
<tr class="separator:aa999d4616a807f9c0dbc4cf037d5fb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b248d14ec39ac4ca13f0eeb7bcdd744"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1QueryClient.html#a2b248d14ec39ac4ca13f0eeb7bcdd744">blocking</a> (const bool b)</td></tr>
<tr class="memdesc:a2b248d14ec39ac4ca13f0eeb7bcdd744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow or abort and reject blocking calls.  <a href="#a2b248d14ec39ac4ca13f0eeb7bcdd744">More...</a><br /></td></tr>
<tr class="separator:a2b248d14ec39ac4ca13f0eeb7bcdd744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974413e8317bf8e2e282bc8ed3022a99"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1QueryClient.html#a974413e8317bf8e2e282bc8ed3022a99">query</a> (const R &amp;request, A &amp;answer)</td></tr>
<tr class="memdesc:a974413e8317bf8e2e282bc8ed3022a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking Query.  <a href="#a974413e8317bf8e2e282bc8ed3022a99">More...</a><br /></td></tr>
<tr class="separator:a974413e8317bf8e2e282bc8ed3022a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813140217aab118404cd04f57e0ca78c"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1QueryClient.html#a813140217aab118404cd04f57e0ca78c">queryRequest</a> (const R &amp;request, Smart::QueryIdPtr &amp;id)</td></tr>
<tr class="memdesc:a813140217aab118404cd04f57e0ca78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous Query.  <a href="#a813140217aab118404cd04f57e0ca78c">More...</a><br /></td></tr>
<tr class="separator:a813140217aab118404cd04f57e0ca78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5770e30cc880253606363b3adb92bdf"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1QueryClient.html#af5770e30cc880253606363b3adb92bdf">queryReceive</a> (const Smart::QueryIdPtr id, A &amp;answer)</td></tr>
<tr class="memdesc:af5770e30cc880253606363b3adb92bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if answer is available.  <a href="#af5770e30cc880253606363b3adb92bdf">More...</a><br /></td></tr>
<tr class="separator:af5770e30cc880253606363b3adb92bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349cc48ae90bcf0c2b10de0d8c1952aa"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1QueryClient.html#a349cc48ae90bcf0c2b10de0d8c1952aa">queryReceiveWait</a> (const Smart::QueryIdPtr id, A &amp;answer, const Smart::Duration &amp;timeout=Smart::Duration::max())</td></tr>
<tr class="memdesc:a349cc48ae90bcf0c2b10de0d8c1952aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for reply.  <a href="#a349cc48ae90bcf0c2b10de0d8c1952aa">More...</a><br /></td></tr>
<tr class="separator:a349cc48ae90bcf0c2b10de0d8c1952aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a9070e5d60a4aee1e8cc9919f815d8"><td class="memItemLeft" align="right" valign="top">Smart::StatusCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartACE_1_1QueryClient.html#ab5a9070e5d60a4aee1e8cc9919f815d8">queryDiscard</a> (const Smart::QueryIdPtr id)</td></tr>
<tr class="memdesc:ab5a9070e5d60a4aee1e8cc9919f815d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard the pending answer with the identifier <em>id</em>  <a href="#ab5a9070e5d60a4aee1e8cc9919f815d8">More...</a><br /></td></tr>
<tr class="separator:ab5a9070e5d60a4aee1e8cc9919f815d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class R, class A&gt;<br />
class SmartACE::QueryClient&lt; R, A &gt;</h3>

<p>Client part of query pattern to perform two-way communication. </p>
<p>Template parameters</p><ul>
<li><b>R</b>: request class (Communication Object)</li>
<li><b>A</b>: answer (reply) class (Communication Object)</li>
</ul>
<p>Demonstrated in <a href="/drupal/?q=node/51#first-example">first example</a> and <a href="/drupal/?q=node/51#third-example">third example</a> </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab3bf577d31a71d8d9b842eac6e2f2a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bf577d31a71d8d9b842eac6e2f2a5a">&#9670;&nbsp;</a></span>QueryClient() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartACE_1_1QueryClient.html">SmartACE::QueryClient</a>&lt; R, A &gt;::<a class="el" href="classSmartACE_1_1QueryClient.html">QueryClient</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSmartACE_1_1WiringSlave.html">WiringSlave</a> *&#160;</td>
          <td class="paramname"><em>slave</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor (exposed as port and wireable from outside by other components). </p>
<p><a class="el" href="classSmartACE_1_1QueryClient.html#a5940a2e3348ad737b72bcf8325fb6c55" title="Add this instance to the set of ports wireable via the wiring pattern from outside the component...">add()</a>/remove() and <a class="el" href="classSmartACE_1_1QueryClient.html#a74984bd7e8023f1318c5bdeb4ad1e85d" title="Connect this service requestor to the denoted service provider. ">connect()</a>/disconnect() can always be used to change the status of the instance. Instance is not connected to a service provider.</p>
<p>Throws exception if port name is already in use.</p><ul>
<li>SMART_PORTALREADYUSED : port name already in use, instance not created</li>
<li>SMART_ERROR : something went wrong, instance not created</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>management class of the component </td></tr>
    <tr><td class="paramname">port</td><td>name of the wireable port </td></tr>
    <tr><td class="paramname">slave</td><td>wiring slave of this component </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5242cd415d2007b08091fe6c6af6e57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5242cd415d2007b08091fe6c6af6e57d">&#9670;&nbsp;</a></span>QueryClient() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartACE_1_1QueryClient.html">SmartACE::QueryClient</a>&lt; R, A &gt;::<a class="el" href="classSmartACE_1_1QueryClient.html">QueryClient</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor (not wired with service provider and not exposed as port). </p>
<p><a class="el" href="classSmartACE_1_1QueryClient.html#a5940a2e3348ad737b72bcf8325fb6c55" title="Add this instance to the set of ports wireable via the wiring pattern from outside the component...">add()</a>/remove() and <a class="el" href="classSmartACE_1_1QueryClient.html#a74984bd7e8023f1318c5bdeb4ad1e85d" title="Connect this service requestor to the denoted service provider. ">connect()</a>/disconnect() can always be used to change the status of the instance. Instance is not connected to a service provider and is not exposed as port wireable from outside the component.</p>
<p>(Currently exception not thrown)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>management class of the component </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff0598729db4c27356a12374fbe9c836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0598729db4c27356a12374fbe9c836">&#9670;&nbsp;</a></span>QueryClient() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartACE_1_1QueryClient.html">SmartACE::QueryClient</a>&lt; R, A &gt;::<a class="el" href="classSmartACE_1_1QueryClient.html">QueryClient</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSmartACE_1_1SmartComponent.html">SmartComponent</a> *&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor (wired with specified service provider). </p>
<p>Connects to the denoted service and blocks until the connection has been established. Blocks infinitely if denoted service becomes not available since constructor performs retries. Blocking is useful to simplify startup of components which have mutual dependencies. <a class="el" href="classSmartACE_1_1QueryClient.html#a5940a2e3348ad737b72bcf8325fb6c55" title="Add this instance to the set of ports wireable via the wiring pattern from outside the component...">add()</a>/remove() and <a class="el" href="classSmartACE_1_1QueryClient.html#a74984bd7e8023f1318c5bdeb4ad1e85d" title="Connect this service requestor to the denoted service provider. ">connect()</a>/disconnect() can always be used to change the status of the instance.</p>
<p>Throws exception if denoted service is incompatible (wrong communication pattern or wrong communication objects).</p><ul>
<li>SMART_INCOMPATIBLESERVICE : the denoted service is incompatible (wrong communication pattern or wrong communication objects) and can therefore not be connected. Instance is not created.</li>
<li>SMART_ERROR : something went wrong, instance not created</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>management class of the component </td></tr>
    <tr><td class="paramname">server</td><td>name of the server </td></tr>
    <tr><td class="paramname">service</td><td>name of the service </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a966cb10cdc3c4935fa9a17183f07595d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966cb10cdc3c4935fa9a17183f07595d">&#9670;&nbsp;</a></span>~QueryClient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSmartACE_1_1QueryClient.html">SmartACE::QueryClient</a>&lt; R, A &gt;::~<a class="el" href="classSmartACE_1_1QueryClient.html">QueryClient</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>The destructor calls <a class="el" href="classSmartACE_1_1QueryClient.html#aac735f9279679952dbf6e6b061d16d00" title="Remove this service requestor from the set of ports wireable via the wiring pattern from outside the ...">remove()</a> and <a class="el" href="classSmartACE_1_1QueryClient.html#aa999d4616a807f9c0dbc4cf037d5fb1d" title="Disconnect the service requestor from the service provider. ">disconnect()</a> and therefore properly cleans up every pending query and removes the instance from the set of wireable ports. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5940a2e3348ad737b72bcf8325fb6c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5940a2e3348ad737b72bcf8325fb6c55">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1QueryClient.html">SmartACE::QueryClient</a>&lt; R, A &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSmartACE_1_1WiringSlave.html">WiringSlave</a> *&#160;</td>
          <td class="paramname"><em>slave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add this instance to the set of ports wireable via the wiring pattern from outside the component. </p>
<p>Already established connections keep valid. If this service requestor is already exposed as port, it is first removed and then added with the new port name. <a class="el" href="classSmartACE_1_1QueryClient.html#a5940a2e3348ad737b72bcf8325fb6c55" title="Add this instance to the set of ports wireable via the wiring pattern from outside the component...">add()</a>/remove() and <a class="el" href="classSmartACE_1_1QueryClient.html#a74984bd7e8023f1318c5bdeb4ad1e85d" title="Connect this service requestor to the denoted service provider. ">connect()</a>/disconnect() can always be used to change the status of this instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slave</td><td>wiring slave of this component </td></tr>
    <tr><td class="paramname">port</td><td>name of port used for wiring</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is OK and this instance added to the set of ports wireable from outside the component</li>
<li>SMART_PORTALREADYUSED : port name already in use and this instance now not available as port</li>
<li>SMART_ERROR : something went wrong </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2b248d14ec39ac4ca13f0eeb7bcdd744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b248d14ec39ac4ca13f0eeb7bcdd744">&#9670;&nbsp;</a></span>blocking()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1QueryClient.html">SmartACE::QueryClient</a>&lt; R, A &gt;::blocking </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow or abort and reject blocking calls. </p>
<p>If blocking is set to false all blocking calls return with SMART_CANCELLED. This can be used to abort blocking calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>(blocking) true/false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : new mode set</li>
<li>SMART_ERROR : something went wrong </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a74984bd7e8023f1318c5bdeb4ad1e85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74984bd7e8023f1318c5bdeb4ad1e85d">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1QueryClient.html">SmartACE::QueryClient</a>&lt; R, A &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect this service requestor to the denoted service provider. </p>
<p>An already established connection is first disconnected. See <a class="el" href="classSmartACE_1_1QueryClient.html#aa999d4616a807f9c0dbc4cf037d5fb1d" title="Disconnect the service requestor from the service provider. ">disconnect()</a> for implications on running or pending queries in that case.</p>
<p>It is no problem to change the connection to a service provider at any point of time irrespective of any calls to <a class="el" href="classSmartACE_1_1QueryClient.html#a974413e8317bf8e2e282bc8ed3022a99" title="Blocking Query. ">query()</a> / <a class="el" href="classSmartACE_1_1QueryClient.html#a813140217aab118404cd04f57e0ca78c" title="Asynchronous Query. ">queryRequest()</a> / <a class="el" href="classSmartACE_1_1QueryClient.html#af5770e30cc880253606363b3adb92bdf" title="Check if answer is available. ">queryReceive()</a> or <a class="el" href="classSmartACE_1_1QueryClient.html#a349cc48ae90bcf0c2b10de0d8c1952aa" title="Wait for reply. ">queryReceiveWait()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">server</td><td>name of the server </td></tr>
    <tr><td class="paramname">service</td><td>name of the service</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is OK and connected to the specified service.</li>
<li>SMART_SERVICEUNAVAILABLE : the specified service is currently not available and the requested connection can not be established. Service requestor is now not connected to any service provider.</li>
<li>SMART_INCOMPATIBLESERVICE : the specified service provider is not compatible (wrong communication pattern or wrong communication objects) to this service requestor and can therefore not be connected. Service requestor is now not connected to any service provider.</li>
<li>SMART_ERROR_COMMUNICATION : communication problems, service requestor is now not connected to any service provider.</li>
<li>SMART_ERROR : something went wrong, service requestor is now not connected to any service provider. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa999d4616a807f9c0dbc4cf037d5fb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa999d4616a807f9c0dbc4cf037d5fb1d">&#9670;&nbsp;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1QueryClient.html">SmartACE::QueryClient</a>&lt; R, A &gt;::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect the service requestor from the service provider. </p>
<p>All blocking queries are aborted with the SMART_DISCONNECTED status code. Already received but not yet picked up answers keep valid and can still be picked up with <a class="el" href="classSmartACE_1_1QueryClient.html#af5770e30cc880253606363b3adb92bdf" title="Check if answer is available. ">queryReceive()</a>/queryReceiveWait(). Not yet received answers at the time of disconnection are lost and calls to <a class="el" href="classSmartACE_1_1QueryClient.html#af5770e30cc880253606363b3adb92bdf" title="Check if answer is available. ">queryReceive()</a>/queryReceiveWait() return with SMART_DISCONNECTED.</p>
<p>It is no problem to change the connection to a service provider at any point of time irrespective of any calls to <a class="el" href="classSmartACE_1_1QueryClient.html#a974413e8317bf8e2e282bc8ed3022a99" title="Blocking Query. ">query()</a> / <a class="el" href="classSmartACE_1_1QueryClient.html#a813140217aab118404cd04f57e0ca78c" title="Asynchronous Query. ">queryRequest()</a> / <a class="el" href="classSmartACE_1_1QueryClient.html#af5770e30cc880253606363b3adb92bdf" title="Check if answer is available. ">queryReceive()</a> or <a class="el" href="classSmartACE_1_1QueryClient.html#a349cc48ae90bcf0c2b10de0d8c1952aa" title="Wait for reply. ">queryReceiveWait()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is OK and service requestor is disconnected from the service provider.</li>
<li>SMART_ERROR_COMMUNICATION : something went wrong at the level of the intercomponent communication. At least the service requestor is in the disconnected state irrespective of the service provider side clean up procedures.</li>
<li>SMART_ERROR : something went wrong. Again at least the service requestor is in the disconnected state. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a974413e8317bf8e2e282bc8ed3022a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974413e8317bf8e2e282bc8ed3022a99">&#9670;&nbsp;</a></span>query()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1QueryClient.html">SmartACE::QueryClient</a>&lt; R, A &gt;::query </td>
          <td>(</td>
          <td class="paramtype">const R &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&#160;</td>
          <td class="paramname"><em>answer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking Query. </p>
<p>Perform a blocking query and return only when the query answer is available. Member function is thread safe and thread reentrant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>send this request to the server (Communication Object) </td></tr>
    <tr><td class="paramname">answer</td><td>returned answer from the server (Communication Object)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code:<ul>
<li>SMART_OK : everything is ok and <em>answer</em> contains answer</li>
<li>SMART_CANCELLED : blocking is not allowed or is not allowed anymore and therefore pending query is aborted, answer is lost and <em>answer</em> contains no valid answer.</li>
<li>SMART_DISCONNECTED : the client is either disconnected and no query can be made or it got disconnected and a pending query is aborted without answer. In both cases, <em>answer</em> is not valid.</li>
<li>SMART_ERROR_COMMUNICATION : communication problems, <em>answer</em> is not valid.</li>
<li>SMART_ERROR : something went wrong, <em>answer</em> is not valid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab5a9070e5d60a4aee1e8cc9919f815d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a9070e5d60a4aee1e8cc9919f815d8">&#9670;&nbsp;</a></span>queryDiscard()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1QueryClient.html">SmartACE::QueryClient</a>&lt; R, A &gt;::queryDiscard </td>
          <td>(</td>
          <td class="paramtype">const Smart::QueryIdPtr&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discard the pending answer with the identifier <em>id</em> </p>
<p>Call this member function if you do not want to get the answer of a request anymore which was invoked by <a class="el" href="classSmartACE_1_1QueryClient.html#a813140217aab118404cd04f57e0ca78c" title="Asynchronous Query. ">queryRequest()</a>. This member function invalidates the identifier <em>id</em>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This member function does NOT abort blocking calls ! This is done by the <a class="el" href="classSmartACE_1_1QueryClient.html#a2b248d14ec39ac4ca13f0eeb7bcdd744" title="Allow or abort and reject blocking calls. ">blocking()</a> member function. It has to be called if you have not yet received an answer and the identifier is still valid, for example due to a CANCELLED return value, and you don't want to get the answer anymore.</dd>
<dd>
It is not allowed to call <a class="el" href="classSmartACE_1_1QueryClient.html#af5770e30cc880253606363b3adb92bdf" title="Check if answer is available. ">queryReceive()</a>, <a class="el" href="classSmartACE_1_1QueryClient.html#a349cc48ae90bcf0c2b10de0d8c1952aa" title="Wait for reply. ">queryReceiveWait()</a> or <a class="el" href="classSmartACE_1_1QueryClient.html#ab5a9070e5d60a4aee1e8cc9919f815d8" title="Discard the pending answer with the identifier id ">queryDiscard()</a> concurrently with the <em>same</em> query id (which is not a restriction since it makes no sense !)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>provides the identifier of the query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code:<ul>
<li>SMART_OK : everything is ok and query with the identifier <em>id</em> discarded.</li>
<li>SMART_WRONGID : no pending query with this identifier.</li>
<li>SMART_ERROR : something went wrong, <em>id</em> not valid any longer. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af5770e30cc880253606363b3adb92bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5770e30cc880253606363b3adb92bdf">&#9670;&nbsp;</a></span>queryReceive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1QueryClient.html">SmartACE::QueryClient</a>&lt; R, A &gt;::queryReceive </td>
          <td>(</td>
          <td class="paramtype">const Smart::QueryIdPtr&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&#160;</td>
          <td class="paramname"><em>answer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if answer is available. </p>
<p>Non-blocking call to fetch the answer belonging to the given identifier. Returns immediately. Member function is thread safe and reentrant.</p>
<dl class="section warning"><dt>Warning</dt><dd>It is not allowed to call <a class="el" href="classSmartACE_1_1QueryClient.html#af5770e30cc880253606363b3adb92bdf" title="Check if answer is available. ">queryReceive()</a>, <a class="el" href="classSmartACE_1_1QueryClient.html#a349cc48ae90bcf0c2b10de0d8c1952aa" title="Wait for reply. ">queryReceiveWait()</a> or <a class="el" href="classSmartACE_1_1QueryClient.html#ab5a9070e5d60a4aee1e8cc9919f815d8" title="Discard the pending answer with the identifier id ">queryDiscard()</a> concurrently with the <em>same</em> query id (which is not a restriction since it makes no sense !)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>provides the identifier of the query </td></tr>
    <tr><td class="paramname">answer</td><td>is set to the answer returned from the server if it was available</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code:<ul>
<li>SMART_OK : everything is ok and <em>answer</em> contains the answer</li>
<li>SMART_WRONGID : no pending query with this identifier available, therefore no valid <em>answer</em> returned.</li>
<li>SMART_NODATA : answer not yet available, therefore try again later. The identifier <em>id</em> keeps valid, but <em>answer</em> contains no valid answer.</li>
<li>SMART_DISCONNECTED : the answer belonging to the <em>id</em> can not be received anymore since the client got disconnected. <em>id</em> is not valid any longer and <em>answer</em> contains no valid answer.</li>
<li>SMART_ERROR : something went wrong, <em>answer</em> contains no answer and <em>id</em> is not valid any longer. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a349cc48ae90bcf0c2b10de0d8c1952aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349cc48ae90bcf0c2b10de0d8c1952aa">&#9670;&nbsp;</a></span>queryReceiveWait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1QueryClient.html">SmartACE::QueryClient</a>&lt; R, A &gt;::queryReceiveWait </td>
          <td>(</td>
          <td class="paramtype">const Smart::QueryIdPtr&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&#160;</td>
          <td class="paramname"><em>answer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Smart::Duration &amp;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>Smart::Duration::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for reply. </p>
<p>Blocking call to fetch the answer belonging to the given identifier. Waits until the answer is received.</p>
<dl class="section warning"><dt>Warning</dt><dd>It is not allowed to call <a class="el" href="classSmartACE_1_1QueryClient.html#af5770e30cc880253606363b3adb92bdf" title="Check if answer is available. ">queryReceive()</a>, <a class="el" href="classSmartACE_1_1QueryClient.html#a349cc48ae90bcf0c2b10de0d8c1952aa" title="Wait for reply. ">queryReceiveWait()</a> or <a class="el" href="classSmartACE_1_1QueryClient.html#ab5a9070e5d60a4aee1e8cc9919f815d8" title="Discard the pending answer with the identifier id ">queryDiscard()</a> concurrently with the <em>same</em> query id (which is not a restriction since it makes no sense !)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>provides the identifier of the query </td></tr>
    <tr><td class="paramname">answer</td><td>is set to the answer returned from the server if it was available </td></tr>
    <tr><td class="paramname">timeout</td><td>the optional maximum waiting time for a query answer (default value max: method blocks indefinitely)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code:<ul>
<li>SMART_OK : everything is ok and <em>answer</em> contains the answer</li>
<li>SMART_WRONGID : no pending query with this identifier available, therefore no valid <em>answer</em> returned.</li>
<li>SMART_CANCELLED : blocking call is not allowed or is not allowed anymore and therefore blocking call is aborted and no valid <em>answer</em> is returned. The query identifier <em>id</em> keeps valid and one can either again call <a class="el" href="classSmartACE_1_1QueryClient.html#af5770e30cc880253606363b3adb92bdf" title="Check if answer is available. ">queryReceive()</a>, <a class="el" href="classSmartACE_1_1QueryClient.html#a349cc48ae90bcf0c2b10de0d8c1952aa" title="Wait for reply. ">queryReceiveWait()</a> or discard the answer by calling <a class="el" href="classSmartACE_1_1QueryClient.html#ab5a9070e5d60a4aee1e8cc9919f815d8" title="Discard the pending answer with the identifier id ">queryDiscard()</a>.</li>
<li>SMART_DISCONNECTED : blocking call is aborted and the answer belonging to <em>id</em> can not be received anymore since client got disconnected. <em>id</em> is not valid any longer and <em>answer</em> contains no valid answer.</li>
<li>SMART_ERROR : something went wrong, <em>answer</em> contains no answer and <em>id</em> is not valid any longer. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a813140217aab118404cd04f57e0ca78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813140217aab118404cd04f57e0ca78c">&#9670;&nbsp;</a></span>queryRequest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1QueryClient.html">SmartACE::QueryClient</a>&lt; R, A &gt;::queryRequest </td>
          <td>(</td>
          <td class="paramtype">const R &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Smart::QueryIdPtr &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous Query. </p>
<p>Perform a query and receive the answer later, returns immediately. Member function is thread safe and reentrant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>send this request to the server (Communication Object) </td></tr>
    <tr><td class="paramname">id</td><td>is set to the identifier which is later used to receive the reply to this request</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code:<ul>
<li>SMART_OK : everything is ok and <em>id</em> contains query identifier used to either fetch or discard the answer.</li>
<li>SMART_DISCONNECTED : request is rejected since client is not connected to a server and therefore <em>id</em> is not a valid identifier.</li>
<li>SMART_ERROR_COMMUNICATION : communication problems, <em>id</em> is not valid.</li>
<li>SMART_ERROR : something went wrong, <em>id</em> is not valid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aac735f9279679952dbf6e6b061d16d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac735f9279679952dbf6e6b061d16d00">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Smart::StatusCode <a class="el" href="classSmartACE_1_1QueryClient.html">SmartACE::QueryClient</a>&lt; R, A &gt;::remove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove this service requestor from the set of ports wireable via the wiring pattern from outside the component. </p>
<p>Already established connections keep valid but can now be changed only from inside and not from outside this component anymore.</p>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is OK and instance not exposed as port anymore (or was not registered as port).</li>
<li>SMART_ERROR : something went wrong but this instance is removed from the set of ports in any case. </li>
</ul>
</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>smartQuery.hh</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
